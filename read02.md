# Readings: Testing and Modules


### Unit tests:
Unit tests are some pieces of code to exercise the input, the output and the behaviour of your code. You can write them anytime you want.our code will be more reliable: after a change you can run your tests and be in peace

## TDD :
Test-Driven Development is a strategy to think (and write!) tests first. More than any checking.

### Unit testing Cycle

-  Write a unit test and make it fail (it needs to fail because the feature isn’t there, right? If this test passes, call the Ghostbusters, really)

-  Write the feature and make the test pass! (you can dance after that)
-Refactor the code — the first version doesn’t need to be the beautiful one (don’t be shy)


----------------------------------------------------------------
### Modular programming:
 Modular programming is the process of breaking a large, unwieldy programming task into separate, smaller, more manageable subtasks or modules. 

### advantages to modularizing:

- Simplicity: Easier to understand and debug the code. Easier to understand and debug the code.Rather than focusing on the entire problem at hand, a module typically focuses on one relatively small portion of the problem.

- Maintainability: Modules are typically designed so that they enforce logical boundaries between different problem domains.

- Reusability: can be used in several different parts of a program, or even in several different programs. This eliminates the need to recreate duplicate code.

- Scoping: Modules typically define a separate namespace, which helps avoid collisions between identifiers in different areas of a program.

----------------------------------------------------------------

# Recursion

The process in which a function calls itself directly or indirectly is called recursion and the corresponding function is called as recursive function. Using recursive algorithm, 

 we use it to solve problem without recursion. So, strictly speaking, recursion usually isn’t necessary.

However, some situations particularly lend themselves to a self-referential definition—for example, the definition of ancestors shown above. If you were devising an algorithm to handle such a case programmatically, a recursive solution would likely be cleaner and more concise.


### How a particular problem is solved using recursion? 
 represent a problem in terms of  more smaller problems, then add one or more base conditions that stop the recursion. 
